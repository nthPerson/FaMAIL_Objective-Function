"""
Configuration for the Spatial Fairness term.

This module defines all configurable parameters for the spatial fairness
computation, including grid dimensions, temporal aggregation settings,
and computation options.

Taxi Count Source Options:
    The N^p term in the service rate formula (DSR = pickups / (N^p × T)) can be
    configured to use either:
    1. "constant" - A fixed number of taxis (num_taxis parameter)
    2. "active_taxis_lookup" - Dynamic lookup from pre-computed active_taxis datasets
    
    The active_taxis_lookup mode uses datasets generated by the active_taxis tool,
    which count unique taxis present in each n×n neighborhood during each time period.
    
Temporal Coverage:
    The raw data covers weekdays (Mon-Fri) across three months:
    - July 2016: 21 weekdays
    - August 2016: 23 weekdays  
    - September 2016: 22 weekdays
    - Total: 66 weekdays
"""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Tuple, Optional, List, Literal
import sys
import os

# Add parent directory to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from base import TermConfig


# Number of weekdays per month in the dataset
WEEKDAYS_JULY = 21
WEEKDAYS_AUGUST = 23
WEEKDAYS_SEPTEMBER = 22
WEEKDAYS_TOTAL = WEEKDAYS_JULY + WEEKDAYS_AUGUST + WEEKDAYS_SEPTEMBER  # 66


@dataclass
class SpatialFairnessConfig(TermConfig):
    """
    Configuration for the Spatial Fairness term.
    
    Attributes:
        period_type: Temporal aggregation level
            - "time_bucket": Each 5-min bucket (finest, 288 periods/day)
            - "hourly": Each hour (24 periods/day)  
            - "daily": Each day (6 periods total)
            - "all": Aggregate all data into single period
        grid_dims: Spatial grid dimensions (x, y)
        
        taxi_count_source: How to determine N^p (number of taxis) in service rate calculation
            - "constant": Use fixed num_taxis value (original behavior)
            - "active_taxis_lookup": Use pre-computed active_taxis dataset
        num_taxis: Number of active taxis (used when taxi_count_source="constant")
        active_taxis_data_path: Path to active_taxis pickle file (used when taxi_count_source="active_taxis_lookup")
        active_taxis_neighborhood: Neighborhood size k used in active_taxis dataset (default 2 for 5×5)
        active_taxis_fallback: Value to use when active_taxis lookup returns 0 (avoid division by zero)
        
        num_days: Number of days in the dataset (21 for July, 23 for Aug, 22 for Sept, 66 for all)
        include_zero_cells: Whether to include cells with zero activity
        data_is_one_indexed: Whether the data uses 1-based indexing
        min_activity_threshold: Minimum total activity to include a cell
    """
    
    # Temporal aggregation
    period_type: str = "hourly"  # "time_bucket", "hourly", "daily", "all"
    
    # Spatial configuration
    grid_dims: Tuple[int, int] = (48, 90)  # (x_cells, y_cells)
    
    # Taxi count configuration (N^p in service rate formula)
    taxi_count_source: Literal["constant", "active_taxis_lookup"] = "constant"
    num_taxis: int = 50                # Fixed number (used when taxi_count_source="constant")
    active_taxis_data_path: Optional[str] = None  # Path to active_taxis_*.pkl
    active_taxis_neighborhood: int = 2  # k value (5×5 neighborhood by default)
    active_taxis_fallback: int = 1      # Fallback when lookup returns 0 (avoid div by zero)
    
    # Temporal coverage
    num_days: float = 21.0             # Days in dataset (21 July, 23 Aug, 22 Sept, 66 total)
    
    # Computation options
    include_zero_cells: bool = True    # Include cells with zero activity
    data_is_one_indexed: bool = True   # Whether source data uses 1-based indexing
    min_activity_threshold: int = 0    # Minimum events to include cell
    
    # Days to include (None = all)
    days_filter: Optional[List[int]] = None  # e.g., [1, 2, 3] for Mon-Wed
    
    # Time buckets to include (None = all)
    time_filter: Optional[Tuple[int, int]] = None  # e.g., (1, 144) for first half of day
    
    def validate(self) -> None:
        """Validate configuration parameters."""
        super().validate()
        
        valid_periods = ["time_bucket", "hourly", "daily", "all"]
        if self.period_type not in valid_periods:
            raise ValueError(
                f"Invalid period_type '{self.period_type}'. "
                f"Must be one of: {valid_periods}"
            )
        
        if self.grid_dims[0] <= 0 or self.grid_dims[1] <= 0:
            raise ValueError("Grid dimensions must be positive")
        
        if self.num_taxis <= 0:
            raise ValueError("num_taxis must be positive")
        
        if self.num_days <= 0:
            raise ValueError("num_days must be positive")
        
        if self.min_activity_threshold < 0:
            raise ValueError("min_activity_threshold must be non-negative")
        
        # Validate taxi_count_source
        valid_sources = ["constant", "active_taxis_lookup"]
        if self.taxi_count_source not in valid_sources:
            raise ValueError(
                f"Invalid taxi_count_source '{self.taxi_count_source}'. "
                f"Must be one of: {valid_sources}"
            )
        
        # If using active_taxis_lookup, validate path
        if self.taxi_count_source == "active_taxis_lookup":
            if self.active_taxis_data_path is None:
                raise ValueError(
                    "active_taxis_data_path must be set when taxi_count_source='active_taxis_lookup'"
                )
            if not Path(self.active_taxis_data_path).exists():
                raise ValueError(
                    f"active_taxis_data_path does not exist: {self.active_taxis_data_path}"
                )
        
        if self.active_taxis_neighborhood < 0:
            raise ValueError("active_taxis_neighborhood must be non-negative")
        
        if self.active_taxis_fallback <= 0:
            raise ValueError("active_taxis_fallback must be positive (avoid division by zero)")


# Predefined configurations for common use cases

# Default configs use constant taxi count (original behavior)
FINE_GRAINED_CONFIG = SpatialFairnessConfig(
    period_type="time_bucket",
    taxi_count_source="constant",
    include_zero_cells=True,
    verbose=False,
)

HOURLY_CONFIG = SpatialFairnessConfig(
    period_type="hourly",
    taxi_count_source="constant",
    include_zero_cells=True,
    verbose=False,
)

DAILY_CONFIG = SpatialFairnessConfig(
    period_type="daily",
    taxi_count_source="constant",
    include_zero_cells=True,
    verbose=False,
)

AGGREGATE_CONFIG = SpatialFairnessConfig(
    period_type="all",
    taxi_count_source="constant",
    num_days=WEEKDAYS_TOTAL,  # All 66 weekdays
    include_zero_cells=True,
    verbose=False,
)

# Peak hours analysis (morning and evening rush)
PEAK_HOURS_CONFIG = SpatialFairnessConfig(
    period_type="hourly",
    taxi_count_source="constant",
    time_filter=(7*12+1, 10*12),  # 7am-10am bucket range
    include_zero_cells=True,
    verbose=False,
)

# Active cells only (exclude cells with no activity)
ACTIVE_CELLS_CONFIG = SpatialFairnessConfig(
    period_type="hourly",
    taxi_count_source="constant",
    include_zero_cells=False,
    min_activity_threshold=1,
    verbose=False,
)


# Factory functions to create configs with active_taxis lookup
def create_active_taxis_hourly_config(
    active_taxis_path: str,
    num_days: float = WEEKDAYS_JULY,
    neighborhood_size: int = 2,
    fallback: int = 1,
) -> SpatialFairnessConfig:
    """
    Create an hourly config using active_taxis lookup for N^p.
    
    Args:
        active_taxis_path: Path to active_taxis_5x5_hourly.pkl
        num_days: Number of days (21 for July, 23 for Aug, 22 for Sept, 66 for all)
        neighborhood_size: Neighborhood k value (default 2 for 5×5)
        fallback: Value when active_taxi count is 0
        
    Returns:
        Configured SpatialFairnessConfig
    """
    return SpatialFairnessConfig(
        period_type="hourly",
        taxi_count_source="active_taxis_lookup",
        active_taxis_data_path=active_taxis_path,
        active_taxis_neighborhood=neighborhood_size,
        active_taxis_fallback=fallback,
        num_days=num_days,
        include_zero_cells=True,
        verbose=False,
    )


def create_active_taxis_daily_config(
    active_taxis_path: str,
    num_days: float = WEEKDAYS_JULY,
    neighborhood_size: int = 2,
    fallback: int = 1,
) -> SpatialFairnessConfig:
    """
    Create a daily config using active_taxis lookup for N^p.
    
    Args:
        active_taxis_path: Path to active_taxis_5x5_daily.pkl
        num_days: Number of days (21 for July, 23 for Aug, 22 for Sept, 66 for all)
        neighborhood_size: Neighborhood k value (default 2 for 5×5)
        fallback: Value when active_taxi count is 0
        
    Returns:
        Configured SpatialFairnessConfig
    """
    return SpatialFairnessConfig(
        period_type="daily",
        taxi_count_source="active_taxis_lookup",
        active_taxis_data_path=active_taxis_path,
        active_taxis_neighborhood=neighborhood_size,
        active_taxis_fallback=fallback,
        num_days=num_days,
        include_zero_cells=True,
        verbose=False,
    )
